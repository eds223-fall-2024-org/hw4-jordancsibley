---
title: "Homework Assignment 4"
subtitle: "Prioritizing potential aquaculture" 
date: last-modified
execute: 
  eval: true
  message: false
  warning: false
format:
  html:
    toc: true
editor_options: 
---

## Background

Aquaculture is a quickly growing field as a means to supply more sustainable protein optitions without the land use. This assignment aims to determine which Exclusive Economic Zones (EEZ) on the West Coast are best suited as marine aquaculture sites for oysters and sugar kelp (Saccharina latissima). Sites are choosen based on a range of suitable sea surface temperatures and depth values for the particular species.

## Set Up

### Libraries

```{r}
#| code-fold: true
#| code-summary: "Show the code"
library(tidyverse)
library(here)
library(sf)
library(terra)
library(stars)
library(tmap)
library(raster)
library(spData)
```

### Data

Sea surface temperature data from 2008 to 2012 generated from NOAA's 5km Daily Satellite Sea Surface Temperature Anomaly v3.1 \[1\]

Bathymetry data comes from General Bathymetric Charts of the Oceans (GEBCO). \[2\]

The designation of Exclusive Economic Zones off the West Coast comes from Marineregions.org, which outlines the boundaries of marine biogeographic areas. \[3\]

#### SST and depth requirements

Oysters:

-   optimal sea surface temperature: 11-30°C
-   depth: 0-70 meters below sea level

Sugar Kelp \[4\]:

-   optimal sea surface temperature: 10-15°C
-   depth: 0-30 meters below sea level

```{r}
#| code-fold: true
#| code-summary: "Show the code"
# ---- Raster stack of sea surface temperatures from 2008 to 2012
# Set directory 
sst_path <- here::here('data')

# Create list of all SST .tif files 
sst_files <- list.files(sst_path, 
                        pattern = glob2rx("*average_annual_sst_*.tif$"),
                        full.names = TRUE)
# Create a raster stack 
sst <- rast(sst_files) 

# ---- Bathymetry data 
depth <- terra::rast(here::here('data', 'depth.tif'))

# ---- EEZ 
eez <- read_sf(here::here('data', 'wc_regions_clean.shp'))

# ---- West coast states  
# load US states
us_states <- spData::us_states

# filter to ca, or, wa
west_coast_states <- us_states %>% 
  filter(NAME %in% c("California", "Oregon", "Washington"))

# NEED TO LEARN HOW TO INCREASE THE EXTENT OF THIS 

```

## Process Data

### Coordinate Reference Systems

```{r}
# Reproject CRS to all match EPSG: 32610
sst<- terra::project(sst, "EPSG: 32610")
depth <- terra::project(depth, "EPSG: 32610")
eez <- st_transform(eez, "EPSG: 32610")
west_coast_states <- st_transform(west_coast_states, "EPSG: 32610")
```

### Initial visualization

```{r}
# View EEZ map
tm_shape(eez) + 
  tm_polygons(col = "rgn", 
              palette = "viridis",
              title = "Region") + 
  tm_layout(legend.outside = TRUE)
# Class
class(eez)
```

The `eez` dataset is a sf dataframe that contains the geometries of the EEZ regions along the west coast of the US. The names of the regions are: Washington, Oregon, Northern California, Central California, and Southern California

```{r}
# View depth map
tm_shape(depth) +
  tm_raster()
# Class 
class(depth)
```

The `depth` data is a terra raster that contains the depths of the ocean (and height of the land) of the west coast of the US. The land (anything higher than depth 0) need to be removed to be useful (potentially)

```{r}
# View sst
tm_shape(sst) + 
  tm_raster(palette = "Blues")

# Class and dimensions
class(sst)
dim(sst)
```

The `sst` data is a terra raster that has 5 layers that gives the average sea surface temperatures of the years 2008 to 2012. I can't exactly tell what units the values are in.

### Finding mean sea surface temperatures from 2008-2012

```{r}
# Mean of raster stack 
sst_mean <- mean(sst)

# View what happened 
tm_shape(sst_mean) + 
  tm_raster(palette = "Blues")
# Dimensions 
dim(sst_mean)
```

### Convert SST from Kelvin to Celsius

```{r}
# Convert to Celsius by subtracting 273.15 
sst_c <- sst_mean - 273.15

# Rename layer name 
names(sst_c) <- "temp_c"

# View what happened
tm_shape(sst_c) + 
  tm_raster(palette = "Blues")
```

Now, the values of the raster make sense (range from 5 to 30 degrees Celsius)

### Crop depth raster to match the extent of SST raster

```{r}
# View it before crop 
map1 <- tm_shape(depth) + 
  tm_raster() + 
  tm_layout(title = "Pre-crop")

# Crop depth extent to that of sst
depth_range <- terra::crop(depth, sst_c)

# View what happened
map2 <- tm_shape(depth_range) + 
  tm_raster() + 
  tm_layout(title = "Post-crop")

tmap_arrange(map1, map2, nrow = 1)
```

### Resolution

```{r}
# Check if resolution of depth and sst match 
res(depth_range) == res(sst_c)

# Change resolution of depth to match sst using nearest neighbor approach
depth_rs <- terra::resample(depth_range, y = sst_c, method = "near")

# View re sampled depth range 
tm_shape(depth_rs) + 
  tm_raster()

# Recheck that resolution now match
res(depth_rs) == res(sst_c)
```

### See if dimensions of data match before merging them

**Make this a more advanced test**

```{r}
# Resolution 
res(depth_rs) == res(sst_c)

# Extent 
ext(depth_rs) == ext(sst_c)

# CRS 
st_crs(depth_rs) == st_crs(sst_c)

# Create raster stack of temp and depth
# depth_temp <- c(depth_rs, sst_c)
# 
# depthmap <- tm_shape(depth_temp[[1]]) +
#   tm_raster() 
#   
# tempmap<- tm_shape(depth_temp[[2]]) +
#   tm_raster(palette = c("blue", "lightblue", "yellow", "orange", "red"))
# 
# tmap_arrange(depthmap, tempmap, nrow=1)
```

## Find Suitable locations

### Reclassify raster for suitable oyster conditions

Set the following values to `1`

-   Depth: 0-70 meters
-   Sea surface temperature: 11-30°C

Any other value set to `0`


```{r}
# Create reclasification matrix for depth 
rcl_depth <- matrix(c(-Inf, -70, 0,  # values -Inf to -70 = 0
                      -70, 0, 1,     # values -70 to 0 = 1
                      0, Inf, 0),    # values 0 to Inf = 0
                    ncol = 3, byrow = TRUE)

# Create reclasification matrix for temp 
rcl_sst <- matrix(c(-Inf,11, 0,# values from -Inf to 11 = 0
                      11, 30, 1, # values 11 to 30 = 1
                      30, Inf, 0), # values 30 to Inf = 0
                    ncol = 3, byrow = TRUE)

# Reclassify the raster for oyster specifications 
depth_oyster <- terra::classify(depth_rs, rcl = rcl_depth)

sst_oyster <- terra::classify(sst_c, rcl = rcl_sst)

# Remove intermediate data names 
#rm(sst, sst_mean, sst_c, depth, depth_range, depth_rs)
```


Creating raster with lapp 
```{r}
# Create raster stack 
oyster_stack <- c(depth_oyster, sst_oyster)

# suitable_area_fun <- function(depth, sst) {
#   depth * sst
#} # Can put this function directly into lapp


# Apply multiplication 
suitable_oyster <- terra::lapp(oyster_stack, fun = function(depth, sst) depth * sst)

tm_shape(suitable_oyster) + 
  tm_raster(palette = c("lightyellow", "lightgreen")) +
  tm_layout(legend.show = FALSE)


# Turn 0 values into NA 
suitable_oyster[suitable_oyster == 0] <- NA #I might not need to do this because if I leave the zero values when I multiple it by eez then I can turn the zero into NA values 
```

## Determine the most suitable EEZ

-   select suitable cells within West Coast EEZs
-   find area of grid cells
-   find the total suitable area within each EEZ
-   hint: it might be helpful to rasterize the EEZ data



i used cell size on a raster that was cropped to the extent of EEZs and had a 1 in all places suitable for oysters and NA in all other places. 
then i multiplied the output of that by the suitable oysters raster to get a new raster that had cell size in each cell that was suitable for oysters. then thats the one i used in zonal!

# rasterize EEZs by region
region_rast <- rasterize(wc_eez, depth, field = "rgn")

# find area of cells in each region
areas <- expanse(oyster_suitability, unit = "km", zones = region_rast)

# join area values to each EEZ
wc_eez_merge <- merge(wc_eez, areas, 
                      by.x = "rgn", 
                      by.y = "zone",
                      all.x = TRUE) %>% 
  mutate(p_area = (area/area_km2) * 100) # find the percentage suitable area in each region


```{r}
# Step 2: Rasterize the eez dataframe using the 'rgn' column
eez_rast <- terra::rasterize(eez, suitable_oyster, field = "rgn")

tm_shape(eez_rast) +
  tm_raster()

# Create dataframe that displays suitable area of each zone
suitable_area <- terra::expanse(suitable_oyster, unit = "km", zones = eez_rast)

# rename columns
suitable_area <- suitable_area %>% 
  rename("suitable_area_km2" = "area",
         "rgn" = "zone")

# Calculate percent of each zone that contains suitable area for oyster aquaculture 
eez_oyster <- eez %>% 
  left_join(suitable_area, by= "rgn") %>% 
  #select(-layer, -rgn_key, -rgn_id) %>% figure out how to remove these columns
  mutate(zone_pct = suitable_area_km2 / area_km2 * 100)

```

Could create a table with this info 

Then make a nicer looking map that includes state outlines from spdata
```{r}
tm_shape(west_coast_states) +
  tm_borders() + 
  tm_shape(eez_rast) +
  tm_raster()
```


## Citations

1.  NOAA Coral Reef Watch. 2008-2012, updated daily. NOAA Coral Reef Watch Version 3.1 Daily 5km Satellite Regional Virtual Station Time Series Data for Southeast Florida, Mar. 12, 2013-Mar. 11, 2014. College Park, Maryland, USA: NOAA Coral Reef Watch. Data set accessed 2024-11-12 at https://coralreefwatch.noaa.gov/product/vs/data.php.

2.  GEBCO Compilation Group (2024) GEBCO 2024 Grid (doi:10.5285/1c44ce99-0a0d-5f4f-e063-7086abc0ea0f)

3.  Flanders Marine Institute (2024): MarineRegions.org. Available online at www.marineregions.org. Consulted on 2024-11-13.

4.  White, N. & Marshall, C.E. 2007. Saccharina latissima Sugar kelp. In Tyler-Walters H. Marine Life Information Network: Biology and Sensitivity Key Information Reviews, \[on-line\]. Plymouth: Marine Biological Association of the United Kingdom. \[cited 12-11-2024\]. Available from: https://www.marlin.ac.uk/species/detail/1375
